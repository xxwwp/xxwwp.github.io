{
    "componentChunkName": "component---src-templates-record-tsx",
    "path": "/record/2",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"简介 动画时间属性 指定了整个动画的运动周期，以及什么时候开始运动或者什么时候结束运动。 如果你不是能看懂后续的属性定义，可以查看 FAQ 部分。 属性列表 begin，指定动画开始时间。 dur，指定动画的持续时间。 end，限制动画持续时间的结束值。 min…","fields":{"path":"/docs/svg/animate/动画时间属性"},"frontmatter":{"title":"svg 动画时间属性","archives":["专栏","svg"],"createAt":"2021-09-01","tags":["svg","动画时间属性","begin","dur","end","min","max","restart","repeatCount","fill"]}},{"excerpt":"简介 动画属性目标属性 用来确定动画作用的属性与其所在的命名空间。 属性列表 attributeName、attributeType attributeName 该属性指定了动画需要操作目标元素的属性。 使用示例： 上面代码中，就指定了 animate 元素执行是 rect…","fields":{"path":"/docs/svg/animate/动画属性目标属性"},"frontmatter":{"title":"svg 动画属性目标属性","archives":["专栏","svg"],"createAt":"2021-08-31","tags":["svg","动画属性目标属性","attributeName","attributeType"]}},{"excerpt":"简介 svg 为动画提供了完整的支持，svg 动画可以让 svg 元素的属性产生周期性的过渡，旋转、平移或者沿路径运动也手到擒来，甚至有自己的事件支持。 svg 的动画在 IE 中没有支持。 相比 css 动画来说，svg 动画是更加强大的。 svg…","fields":{"path":"/docs/svg/动画介绍"},"frontmatter":{"title":"svg 动画介绍","archives":["专栏","svg"],"createAt":"2021-08-31","tags":["svg","动画介绍","动画参考"]}},{"excerpt":"简介 Turbulence [ˈtɜːrbjələns] 翻译是 “湍流、紊（wěn）乱” 的意思。 feTurbulence 直译并不是纹理，它会通过 Perlin Turbulence 函数来生成图像，生成类似大理石、云纹的纹理。 关于 Perlin Turbulence…","fields":{"path":"/docs/svg/filter/噪点"},"frontmatter":{"title":"svg 噪点 feTurbulence","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","噪点","feTurbulence"]}},{"excerpt":"简介 feImage 用来在滤镜中引入一张图片，并把像素数据作为输出。 因为 feImage 会输出像素，所以把其他 svg 当做图片引入时就会丢失矢量性。MDN 上称这个叫做栅格化。 它有两个专有属性 xlink:href 和 preserveAspectRatio…","fields":{"path":"/docs/svg/filter/图片"},"frontmatter":{"title":"svg 图片 feImage","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","图片","feImage"]}},{"excerpt":"简介 Morphology 被译为 “形态、形态学”。 feMorphology…","fields":{"path":"/docs/svg/filter/形态"},"frontmatter":{"title":"svg 形态 feMorphology","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","形态","feMorphology","轮廓增肥","轮廓增粗"]}},{"excerpt":"feTitle 滤镜和 pattern 滤镜类似，用来重复填充一个图像。 feTitle 没有任何特殊属性，仅仅值需要一个输入源即可。使用如下： 上面代码使用一张图片作为 feTitle…","fields":{"path":"/docs/svg/filter/瓦砾"},"frontmatter":{"title":"svg 瓦砾 feTile","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","瓦砾","feTile","重复填充","堆砌图像"]}},{"excerpt":"简介 feDisplacementMap 滤镜可以把通过一个图像的色彩来从新映射另一图像的位置。 关于这个滤镜，我并没有找到很好的示例，因为它并不是很灵活。 位置的映射公式如下： 这个公式并不是很难，P’(x,y) 是新图的像素点，它由原图 P…","fields":{"path":"/docs/svg/filter/移位映射"},"frontmatter":{"title":"svg 移位映射 feDisplacementMap","archives":["专栏","svg"],"createAt":"2021-08-26","tags":["svg","移位映射","feDisplacementMap"]}},{"excerpt":"简介 光照这一节的计算实在太抽象了，W3C 上文档真的是能写多少写多少，几个公式就结束了。我没有去推算过，主要是无能为力，没学过计算机图形学。本节仅从效果上探讨 svg 的光照效果。 SVG…","fields":{"path":"/docs/svg/filter/光照滤镜"},"frontmatter":{"title":"svg 光照滤镜 feDiffuseLighting、feDistantLight、fePointLight、feSpecularLighting、feSpotLight","archives":["专栏","svg"],"createAt":"2021-08-24","tags":["svg","光照滤镜","feDiffuseLighting","feDistantLight","fePointLight","feSpecularLighting","feSpotLight","光照效果","远光","聚光"]}},{"excerpt":"简介 <feConvolveMatrix> 为卷积矩阵滤镜，该滤镜可以让一个像素的色值与其周围的像素点进行组合，通过卷积实现一些成像操作。比如模糊、边缘检测、锐化、压花和斜角等。 卷积矩阵基于一个 n * m…","fields":{"path":"/docs/svg/filter/卷积矩阵"},"frontmatter":{"title":"svg 卷积矩阵 feConvolveMatrix","archives":["专栏","svg"],"createAt":"2021-08-24","tags":["svg","卷积矩阵","feConvolveMatrix","压花","浮雕"]}}]}},"pageContext":{"limit":10,"skip":10,"numPages":4,"currentPage":2}},
    "staticQueryHashes": []}