{
    "componentChunkName": "component---src-pages-search-tsx",
    "path": "/search/",
    "result": {"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"思路 react 的 ssr 最低最低也要把下面几个操作完成： 转化 jsx：把 jsx 或者 tsx 代码转化为普通代码 模板注入：使用 react-dom 的服务器端渲染功能把组件渲染成静态文本，然后丢到 HTTP 响应报文中 吸水反应：在客户端添加逻辑挂载，react…","fields":{"path":"/docs/blogs/react ssr 极简实现"},"frontmatter":{"title":"react ssr 极简实现","archives":["博客"],"createAt":"2022-07-01","tags":["react","ssr","server site rendering"]}},{"excerpt":"结果：写了一个叫 storage-timing 的库。 Some days I feel different than the day before. ---《本杰明 · 巴顿奇事》 入行那年 当年高考英语才 40 多分，勉勉强强上了个本科，C 语言第一节课我就懵了大 1…","fields":{"path":"/docs/essay/记录第一次写库"},"frontmatter":{"title":"记录第一次写库","archives":["随笔"],"createAt":"2022-06-24","tags":["人生","工作"]}},{"excerpt":"简介 本笔记参考 rollup 官方文档 编写，官方也有提供中文文档，但是好像没人维护了，我看到一半发现有很多插件和用法产生滞留，不太建议查看中文文档。 安装与 Hello World 官方推荐全局安装，这样就可以使用全局命令 rollup…","fields":{"path":"/docs/note/rollup"},"frontmatter":{"title":"rollup 笔记","archives":["笔记"],"createAt":"2022-03-14","tags":["rollup","打包","构建工具","babel","typescript"]}},{"excerpt":"简介 产品新增了一个拖拽排序的需求，我本来已经找到了 Vue Fraggable 这个库，但是这库不支持 Vue3，很遗憾，只有自己造轮子了。 很早就知道 H5 拖拽相关的 API…","fields":{"path":"/docs/blogs/70 行代码在 Vue3 中实现网格布局拖放排序"},"frontmatter":{"title":"70 行代码在 Vue3 中实现网格布局拖放排序","archives":["博客"],"createAt":"2022-01-14","tags":["Vue3","Grid","drag","drop","sort","排序","拖拽"]}},{"excerpt":"postcss 是什么 postcss 是一个用来处理 css 的工具，支持 JavaScript 或者 NodeJS。你可能听过 autoprefixer 库，它用来给 css 代码添加兼容性前缀，然而这个库只是 postcss 的一个插件而已。 PostCSS…","fields":{"path":"/docs/notes/postcss - helloworld"},"frontmatter":{"title":"postcss - helloworld","archives":["笔记"],"createAt":"2021-12-29","tags":["postcss","autoprefixer","css"]}},{"excerpt":"脚手架安装 我比较喜欢使用 vue-cli，在 vue3 中，使用安装脚手架比较简单，使用以下命令： 当然也有很多其他安装方式，比如 Vite，cdn，或者直接获取 vue 的库安装，详见官网 应用 创建 不同于 vue2 版本的 new Vue 语句，vue…","fields":{"path":"/docs/notes/vue2 与 vue3 变化总结"},"frontmatter":{"title":"vue2 与 vue3 变化总结","archives":["笔记"],"createAt":"2021-11-06","tags":["vue2","vue3","版本迁移"]}},{"excerpt":"问题出现 使用 vue 脚手架新建项目，出现无法找到 package.json 和 tsconfig.json 文件，导致引入一个 HelloWord.vue 都报错的问题。  这个问题实际上源于 vscode 的插件 vetur，这个插件只会在根路径寻找 tsconfig…","fields":{"path":"/docs/notes/关于在 vue 脚手架中使用 typescript 无法找到模块的问题解决"},"frontmatter":{"title":"关于在 vue 脚手架中使用 typescript 无法找到模块的问题解决","archives":["笔记"],"createAt":"2021-11-06","tags":["@vue/cli","vetur","vscode","vue"]}},{"excerpt":"实现 使用 ts 实现 编译版本： 使用 copy 函数类型如下： 参数 text：需要复制的文本 返回值：成功返回 true，反之 false 示例 FAQ 切入式 H5 能否实现？ 大多数情况下是不能的，我和同事只是测试了 IOS…","fields":{"path":"/docs/notes/复制功能"},"frontmatter":{"title":"复制功能","archives":["笔记"],"createAt":"2021-10-25","tags":["复制","copy","拷贝","js","BOM"]}},{"excerpt":"前言 axios 算是当下最热门的前端 ajax 处理库，它简单易上手，扩展性强，功能齐全。 我之前在 react 中处理 axios 的封装一直没有找到很好的方式，因为 axios 是非常独立，并且提供的各种 api 都是一次性配置，例如 axios.create、axios…","fields":{"path":"/docs/blogs/如何更好的在 react 中使用 axios 的拦截器"},"frontmatter":{"title":"如何更好的在 react 中使用 axios 的拦截器","archives":["博客","前端"],"createAt":"2021-09-28","tags":["react","axios","拦截器","状态跟踪","状态丢失","axios 拦截器封闭性","请求","封装"]}},{"excerpt":"https://stackoverflow.com/questions/40443806/webpack-resolve-alias-does-not-work-with-typescript https://create-react-app.dev/docs/importing…","fields":{"path":"/docs/blogs/typescript_与_webpack_alias_混用"},"frontmatter":{"title":"typescript_与_webpack_alias_混用","archives":["博客"],"createAt":"2021-09-28","tags":["none"]}},{"excerpt":"简介 markdown 模板","fields":{"path":"/docs/urllink"},"frontmatter":{"title":"文章标题","archives":["archives1","archives2"],"createAt":"2021-09-10","tags":["tag1","tag2","tag3"]}},{"excerpt":"元数据 元数据为 yaml 格式的数据，写在文章最开始，使用 ---\\n 与 \\n--- 进行包裹。yaml 格式非常严格，缩进使用两个空格而不是 tab 缩进。 示例： 元数据提供文章的所有基础数据，这些数据将用于渲染或标识。数据列表如下： title = string…","fields":{"path":"/docs/Markdown_writing_specification"},"frontmatter":{"title":"markdown 编写规范","archives":["文章"],"createAt":"2021-09-10","tags":null}},{"excerpt":"动画取值属性 动画取值属性 定义了动画中目标属性的值随时间是如何变化的，动画取值属性提供了对关键帧的相对时间和离散值之间的插值方法和控制。 比如填充颜色从浅到深，光照滤镜的光源移动位置，噪点矩阵的混乱程度等等，都可以通过动画取值属性来设置。 属性列表 calcMode…","fields":{"path":"/docs/svg/animate/动画取值属性"},"frontmatter":{"title":"svg 动画取值属性","archives":["专栏","svg"],"createAt":"2021-09-03","tags":["svg","动画取值属性","calcMode","values","keyTimes","keySplines","from","to","by"]}},{"excerpt":"简介 动画累加属性 用来设置动画是否基于上个动画最终值或者静止状态进行动画的累加。 比如一个动画是让 width 从 0 到 10，那么动画累加属性可以让该动画在第二个周期变为让 width 从 10 到 20，第三个周期从 20 到 3…","fields":{"path":"/docs/svg/animate/动画累加属性"},"frontmatter":{"title":"svg 动画累加属性","archives":["专栏","svg"],"createAt":"2021-09-03","tags":["svg","动画累加属性","additive","accumulate"]}},{"excerpt":"简介 svg 中的动画元素一共有 5 个，其中 animateColor 不推荐使用，在未来的规范可能会将其废弃，还有一个动画组件元素 mpath，所以常用的还剩下以下 5 个： animate，最基本的动画元素，配合动画相关属性进行动画设置。 set…","fields":{"path":"/docs/svg/animate/动画元素"},"frontmatter":{"title":"svg 动画元素","archives":["专栏","svg"],"createAt":"2021-09-03","tags":["svg","动画元素","animate","set","animateMotion","mpath","animateTransform"]}},{"excerpt":"简介 动画时间属性 指定了整个动画的运动周期，以及什么时候开始运动或者什么时候结束运动。 如果你不是能看懂后续的属性定义，可以查看 FAQ 部分。 属性列表 begin，指定动画开始时间。 dur，指定动画的持续时间。 end，限制动画持续时间的结束值。 min…","fields":{"path":"/docs/svg/animate/动画时间属性"},"frontmatter":{"title":"svg 动画时间属性","archives":["专栏","svg"],"createAt":"2021-09-01","tags":["svg","动画时间属性","begin","dur","end","min","max","restart","repeatCount","fill"]}},{"excerpt":"简介 动画属性目标属性 用来确定动画作用的属性与其所在的命名空间。 属性列表 attributeName、attributeType attributeName 该属性指定了动画需要操作目标元素的属性。 使用示例： 上面代码中，就指定了 animate 元素执行是 rect…","fields":{"path":"/docs/svg/animate/动画属性目标属性"},"frontmatter":{"title":"svg 动画属性目标属性","archives":["专栏","svg"],"createAt":"2021-08-31","tags":["svg","动画属性目标属性","attributeName","attributeType"]}},{"excerpt":"简介 svg 为动画提供了完整的支持，svg 动画可以让 svg 元素的属性产生周期性的过渡，旋转、平移或者沿路径运动也手到擒来，甚至有自己的事件支持。 svg 的动画在 IE 中没有支持。 相比 css 动画来说，svg 动画是更加强大的。 svg…","fields":{"path":"/docs/svg/动画介绍"},"frontmatter":{"title":"svg 动画介绍","archives":["专栏","svg"],"createAt":"2021-08-31","tags":["svg","动画介绍","动画参考"]}},{"excerpt":"简介 Turbulence [ˈtɜːrbjələns] 翻译是 “湍流、紊（wěn）乱” 的意思。 feTurbulence 直译并不是纹理，它会通过 Perlin Turbulence 函数来生成图像，生成类似大理石、云纹的纹理。 关于 Perlin Turbulence…","fields":{"path":"/docs/svg/filter/噪点"},"frontmatter":{"title":"svg 噪点 feTurbulence","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","噪点","feTurbulence"]}},{"excerpt":"简介 Morphology 被译为 “形态、形态学”。 feMorphology…","fields":{"path":"/docs/svg/filter/形态"},"frontmatter":{"title":"svg 形态 feMorphology","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","形态","feMorphology","轮廓增肥","轮廓增粗"]}},{"excerpt":"feTitle 滤镜和 pattern 滤镜类似，用来重复填充一个图像。 feTitle 没有任何特殊属性，仅仅值需要一个输入源即可。使用如下： 上面代码使用一张图片作为 feTitle…","fields":{"path":"/docs/svg/filter/瓦砾"},"frontmatter":{"title":"svg 瓦砾 feTile","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","瓦砾","feTile","重复填充","堆砌图像"]}},{"excerpt":"简介 feImage 用来在滤镜中引入一张图片，并把像素数据作为输出。 因为 feImage 会输出像素，所以把其他 svg 当做图片引入时就会丢失矢量性。MDN 上称这个叫做栅格化。 它有两个专有属性 xlink:href 和 preserveAspectRatio…","fields":{"path":"/docs/svg/filter/图片"},"frontmatter":{"title":"svg 图片 feImage","archives":["专栏","svg"],"createAt":"2021-08-27","tags":["svg","图片","feImage"]}},{"excerpt":"简介 feDisplacementMap 滤镜可以把通过一个图像的色彩来从新映射另一图像的位置。 关于这个滤镜，我并没有找到很好的示例，因为它并不是很灵活。 位置的映射公式如下： 这个公式并不是很难，P’(x,y) 是新图的像素点，它由原图 P…","fields":{"path":"/docs/svg/filter/移位映射"},"frontmatter":{"title":"svg 移位映射 feDisplacementMap","archives":["专栏","svg"],"createAt":"2021-08-26","tags":["svg","移位映射","feDisplacementMap"]}},{"excerpt":"简介 <feConvolveMatrix> 为卷积矩阵滤镜，该滤镜可以让一个像素的色值与其周围的像素点进行组合，通过卷积实现一些成像操作。比如模糊、边缘检测、锐化、压花和斜角等。 卷积矩阵基于一个 n * m…","fields":{"path":"/docs/svg/filter/卷积矩阵"},"frontmatter":{"title":"svg 卷积矩阵 feConvolveMatrix","archives":["专栏","svg"],"createAt":"2021-08-24","tags":["svg","卷积矩阵","feConvolveMatrix","压花","浮雕"]}},{"excerpt":"简介 光照这一节的计算实在太抽象了，W3C 上文档真的是能写多少写多少，几个公式就结束了。我没有去推算过，主要是无能为力，没学过计算机图形学。本节仅从效果上探讨 svg 的光照效果。 SVG…","fields":{"path":"/docs/svg/filter/光照滤镜"},"frontmatter":{"title":"svg 光照滤镜 feDiffuseLighting、feDistantLight、fePointLight、feSpecularLighting、feSpotLight","archives":["专栏","svg"],"createAt":"2021-08-24","tags":["svg","光照滤镜","feDiffuseLighting","feDistantLight","fePointLight","feSpecularLighting","feSpotLight","光照效果","远光","聚光"]}},{"excerpt":"简介 <feComposite> 滤镜用来处理两个图像的智能像素组合，它和 <feBlend> 滤镜类似，也有两个输入源 in 和 in2。 它还有一个重要的属性 operator 来决定如何处理两个图像的组合。 这个滤镜的兼容性非常差，即使我在 Chrome 92.x…","fields":{"path":"/docs/svg/filter/合成"},"frontmatter":{"title":"svg 合成 feComposite","archives":["专栏","svg"],"createAt":"2021-08-19","tags":["svg","feComposite","operator"]}},{"excerpt":"介绍 <feMerge> 滤镜允许你不按顺序应用多个滤镜效果，<feMerge> 滤镜本身没有任何特殊属性，它通过包裹多个 <feMergeNode> 元素来应用多个滤镜。 <feMergeNode> 节点使用 in…","fields":{"path":"/docs/svg/filter/合并"},"frontmatter":{"title":"svg 合并 feMerge、feMergeNode","archives":["专栏","svg"],"createAt":"2021-08-19","tags":["svg","feMerge","feMergeNode"]}},{"excerpt":"简介 <feDropShadow> 阴影滤镜非常简单，它只有三个属性： dx：投影的 x 偏移。 dy：投影的 y 偏移。 stdDeviation：该属性定义了阴影中模糊操作的标准偏差。数值越大，图案立体效果越明显，值为…","fields":{"path":"/docs/svg/filter/阴影滤镜"},"frontmatter":{"title":"svg 阴影滤镜 feDropShadow","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","阴影滤镜","feDropShadow","泛色","flood-color","flood-opacity"]}},{"excerpt":"混合 <feBlend> 混合滤镜用来把两个滤镜或者输入源进行混合，混合的方式也有多种。 <feBlend> 滤镜有以下属性： 属性 值类型 描述 in 参考这里 输入源 1 in2 同 in 属性 输入源 2 mode normal | multiply | screen…","fields":{"path":"/docs/svg/filter/混合"},"frontmatter":{"title":"svg 混合 feBlend","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","滤镜","混合","混合模式","feBlend"]}},{"excerpt":"使用 <feFlood> 滤镜可以在矩形滤镜区域内进行泛色填充，<feFlood> 的填充的区域始终是一个矩形。它的效果类似遮罩 <mask>。 它有两个属性分别是： flood-color 这个属性用来设置填充颜色； flood-opacity…","fields":{"path":"/docs/svg/filter/泛色"},"frontmatter":{"title":"svg 泛色 feFlood","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","滤镜","泛色","feFlood","flood-color","flood-opacity"]}},{"excerpt":"<feGaussianBlur> 是高斯模糊滤镜。 该滤镜对输入图像进行高斯模糊，属性 stdDeviation 中指定的数量定义了钟形。 示例： 效果如下： 高斯模糊效果就像近视一样。","fields":{"path":"/docs/svg/filter/高斯模糊"},"frontmatter":{"title":"svg 高斯模糊 feGaussianBlue","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","滤镜","高斯模糊","stdDeviation","feGaussianBlue"]}},{"excerpt":"使用 <feOffset> 滤镜可以设置图案的偏移量，类似 css 中的相对定位效果。 可以使用 dx、dy…","fields":{"path":"/docs/svg/filter/偏移"},"frontmatter":{"title":"svg 偏移 feOffset","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","滤镜","偏移","feOffset"]}},{"excerpt":"认识 色彩矩阵采用矩阵乘法来对图案从新进行色彩计算，它可以重新计算 R、G、B、A 四个值的比重。 比如说你不想去掉蓝光，又或者希望得到一张黑白图，又或者改变明暗度等等，都可以使用色彩矩阵来实现。 <fecolormatrix…","fields":{"path":"/docs/svg/filter/色彩矩阵"},"frontmatter":{"title":"svg 色彩矩阵 feColorMatrix","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","滤镜","色彩矩阵","feColorMatrix","color","matrix"]}},{"excerpt":"介绍 <feComponentTransfer> 滤镜为组件置换滤镜，它允许你配合 <feFuncR>、<feFuncG>、<feFuncB>、<feFuncA> 这些色彩通道组件对 RGBA…","fields":{"path":"/docs/svg/filter/单通道色彩从分布"},"frontmatter":{"title":"svg 单通道色彩从分布 feComponentTransfer 与 feFunc 相关函数","archives":["专栏","svg"],"createAt":"2021-08-18","tags":["svg","feComponentTransfer","feFunc","table 表格分布","discrete 离散分布","linear 线性分布","gamma 伽马分布"]}},{"excerpt":"概述 svg 使用 xml 语言编写，早版本的 svg 文件需要编写 DTD，类似： svg 后续版本并没有这种说明，因为这样的代码无法正常嵌入到其他 xml 文档中，xml 有很多种，不同 xml 文件可能会复用同一元素名导致解析出错，比如 xhtml 和 svg…","fields":{"path":"/docs/svg/简介"},"frontmatter":{"title":"svg 简介","archives":["专栏","svg"],"createAt":"2021-08-11","tags":["svg","格式","xml","引入方式","坐标","viewBox","内嵌"]}},{"excerpt":"<g>、<use /> 元素 使用 <g> 元素可以把属性赋给一组 svg 元素，比如： 此时圆形和矩形区域都会填充红色。 但是它的功能远不止于此，它同时还是用来组合对象的容器，你可以把一些组合放到 <g> 元素中，然后给 <g> 元素一个 id 属性，之后可以使用 <use…","fields":{"path":"/docs/svg/基础变形"},"frontmatter":{"title":"svg 基础变形","archives":["专栏","svg"],"createAt":"2021-08-11","tags":["svg","g","use","transform"]}},{"excerpt":"剪裁 svg 中的剪裁更像是过滤的效果，筛选出需要的部分，把不需要的部分移除。 剪裁之前，需要定义一个剪裁区域，在 <defs> 元素中使用 <clipPath> 元素描述。<clipPath> 元素也需要有一个 id，方便其他元素引用。在 <clipPath…","fields":{"path":"/docs/svg/剪裁和遮罩"},"frontmatter":{"title":"svg 剪裁和遮罩","archives":["专栏","svg"],"createAt":"2021-08-11","tags":["svg","剪裁","clipPath","遮罩","mask","透明度"]}},{"excerpt":"参考 图像 类似于 HTML 中 的 <img> 元素，svg 中可以使用 <image> 元素插入图片，支持 PNG、JPG 和 SVG 等类型的图片。 嵌入的图片被定义为一个普通的 svg 元素，所以你可以对其进行剪裁、遮罩、变形等。 <image/> 元素和 <rect…","fields":{"path":"/docs/svg/资源嵌入"},"frontmatter":{"title":"svg 资源嵌入","archives":["专栏","svg"],"createAt":"2021-08-11","tags":["svg","图片","图像","图形","资源嵌入","image"]}},{"excerpt":"简介 svg 中的滤镜功能十分丰富，它以多种方式修改原图案，已达到不同的效果，例如毛玻璃特效、高斯模糊、泛色、光照等等。 svg 中的滤镜使用 <filter> 元素定义，不同的滤镜使用不同内部元素，svg 提供以下滤镜： <feBlend…","fields":{"path":"/docs/svg/滤镜"},"frontmatter":{"title":"svg 滤镜 filter","archives":["专栏","svg"],"createAt":"2021-08-11","tags":["svg","滤镜","filter","位置","尺寸","filterunits"]}},{"excerpt":"线性渐变 线性渐变的描述使用 <linearGradient> 节点，类似这样： 效果如下： 线性渐变的中间节点使用 <stop> 元素描述，它有三个常用属性： offset：用来描述渐变的位置的百分比，可以使用小数。这个属性不能使用 css 编写。 stop-color…","fields":{"path":"/docs/svg/渐变"},"frontmatter":{"title":"svg 渐变、linearGradient 与 radialGradient","archives":["专栏","svg"],"createAt":"2021-08-10","tags":["svg","linearGradient","radialGradient","stop","线性渐变","径向渐变","末端处理","渐变单元"]}},{"excerpt":"简介 Patterns （图案）是 svg 对基础零件的一种组合方式，它可让使用者预先设计一些图形的组合排列，然后在后续根据不同环境多次使用。 图案使用 <pattern> 元素描述，它同样需要一个 id，以方便后续元素对其进行引用，除此之外，它还有以下属性： width…","fields":{"path":"/docs/svg/图案"},"frontmatter":{"title":"svg 图案 pattern","archives":["专栏","svg"],"createAt":"2021-08-10","tags":["svg","pattern","objectBoundingBox","patternUnits","userSpaceOnUse","patternContentUnits"]}},{"excerpt":"svg 中有两种文本模式，一种是写在图像中的文本，另一种是 svg 字体。本节只探讨前者。 文本 在 svg 中内嵌一个文本使用 <text> 元素，它的内部文本会被渲染，可以通过属性 x 和 y 来对其进行简单的定位，比如： 可以使用 text-anchor…","fields":{"path":"/docs/svg/文本与超链接"},"frontmatter":{"title":"svg 文本与超链接","archives":["专栏","svg"],"createAt":"2021-08-10","tags":["svg","文本","text","link","超链接"]}},{"excerpt":"基本形状 矩形 矩形 由 <rect /> 元素组成，有以下属性： x：矩形左上角的 x 位置 y：矩形左上角的 y 位置 width：矩形的宽度 height：矩形的高度 rx：圆角的 x 方位的半径（rx 和 ry 仅设置一个时，值会同时作用在 x 和 y 轴两个方向） ry…","fields":{"path":"/docs/svg/线条与着色"},"frontmatter":{"title":"svg 线条与着色","archives":["专栏","svg"],"createAt":"2021-08-08","tags":["svg","线条","line","着色","stroke","矩形","rect","圆形","circle","椭圆","ellipse","折线","polyline","直线","路径","path","贝塞尔曲线","弧形","填充","边框","色值","不透明度","描边","填充规则","css"]}}]}},"pageContext":{}},
    "staticQueryHashes": []}