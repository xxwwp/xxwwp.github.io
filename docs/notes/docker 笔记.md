---
title: docker 笔记
slug: /docs/notes/docker 笔记
createAt: 2022-07-26
publish: false
tags:
  - docker
archives:
  - 笔记
desc:
---

## 序

本笔记记录我的 docker 学习记录，参考教材来源于 [docker 教程][4] 和 [docker | 菜鸟教程][5]。

其中，[docker | 菜鸟教程][5] 的文章更工具化和短篇，可以快速查询知识点。而 [docker 教程][4] 更加完整，毕竟是官网中译，可以查询更多的 api，但是也更加碎片化。

学习关键使用 windows 10 系统，安装参考 docker 官网推荐方式。

## 安装

docker 运行在 linux 系统中，所以默认情况下，docker 是不能在 windows 系统中使用的。在 windows 中安装 docker 需要安装官方的桌面工具 **Docker Desktop**，**并且安装 WSL 2 支持 linux 虚拟机启动**，不然 docker 就无法正常工作。

要测试 docker 是否已经安装好，可以尝试命令：

```shell
docker --version
```

## 概念

哲学三问：docker 是什么？用在哪儿？能干啥？

docker 是什么？

docker 可以被理解为一个虚拟机管理器。**docker 指定的一个环境包来构建一个虚拟机。** 例如使用 ubuntu 的包来构建一个 ubuntu 的虚拟机环境。同时用户可以配置这个虚拟机到一个指定环境，比如 lamp，nodejs，rust，ruby 等等。因为是虚拟机，所以回滚、重做等操作的成本极低，同时安全性扫描等都可以在本机直接进行。

**docker 把指定的环境包称作 image（镜像或图像），根据 image 构建的虚拟机被称作 container （容器）。** 大白话就是，镜像其实就是指某个配置好的系统安装包，例如 ubuntu，centos，这个安装包还可以预先进行配置，例如配置 lamp 或 nodejs 等基础应用后，再进行打包，docker 可以为这些镜像生成独立的虚拟机运行。而容器其实就是根据系统镜像创建的虚拟机而已。说爆了，docker 就类似一个虚拟机管理器。

**因为容器是虚拟机，所以 docker 为容器之间的通讯建立了 network （网络）**，docker 网络并不难，并不是需要网络工程师的水平才能使用，就类似打开你家的 Wifi 局域网管理而已。

docker 用在哪儿？

docker 肯定不是用来创建虚拟机进行测试或者学习的，当然也可以这么做，但是就太大材小用了。同其他虚拟机管理工具不同，docker 主要作用于生产环境而非开发环境，docker 使用命令行完成了虚拟机管理的一系列操作，例如镜像的增删改查、发布或拉取等，还有容器的增删改查、重启或暂停等等。可以轻松的使用几行甚至一行命令就创建一个虚拟机，因为是虚拟机，在里面进行的所有环境搭建和部署都不会污染到服务器本身。

docker 能干啥？

docker 为应用创建了独立可视化的环境，随着代码和架构像滚雪球一样滚大的时候，底层环境也会随之变化，不少的情况下是为了填坑。比如引入了某个库，依赖要求的版本太高，不得不升级，升级带来的 bug，不得不打补丁，但是这些操作很有可能都是遗留性问题，也就是说可以通过更换系统架构来消除，但是因为服务器上构建的应用各不相同，前端、后端、数据库、安全等等全部都挤到一起，很难确定更新的潜在隐患，也很难得到一套完善的处理方案。

这个时候 docker 站了出来，docker 可以为各个应用分配虚拟环境，让应用仅保持一个 I/O 进行通信，可能是 tcp/ip，又或者是应用层的 http。docker 还为环境的更新做出了完善的支持，不同开发端之间的冲突和依赖得到了分离，让开发者对本身所处的环境有了清楚的认识。

### 镜像

docker 有一个开放的镜像库 [Dockerhub][7]，这里记录了很多官方或第三方的镜像包。例如仅仅是纯净系统的 centos，ubuntu，又或者是含有应用的 mysql，python，nginx，httpd，再或者是集成架构的 lamp，都可以在镜像库中找到。其次，用户还可以为自己的环境构建镜像包，并发布到 Dockerhub，方便拉起部署。

大多数镜像都只做一件事，这样可以有效的降低业务架构的耦合度，比如这么一套环境 ubuntu + python + nginx + nodejs + mysql，虽然可以使用 docker 构建一个 ubuntu 系统进行配置，但是这样回到起点，没有对各部分业务进行解耦，正确的做法是解耦到 4 个容器中，例如 ubuntu + python、ubuntu + nginx、ubuntu + nodejs、ubuntu + mysql，尽管这样做看上去很麻烦，但实际操作却不复杂，并且很好的对架构进行了解耦。为此用户需要构建 4 个镜像并对其进行管理，对各个镜像进行独立的配置。

镜像的来源基本都基于 [Dockerhub][7]，当然也有其他的镜像库，但是官方的肯定要香一些。

Dockerhub 类似 Github，本质是镜像仓库，用户可以对仓库中的镜像进行拉取 pull、推送 push 或查找 search 等操作。

拉取一个镜像很简单，例如使用 `docker pull ubuntu:15.10` 命令拉取 ubuntu 的 15.10 版本：

```shell
PS > docker pull ubuntu:15.10
15.10: Pulling from library/ubuntu
Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3
Status: Downloaded newer image for ubuntu:15.10
docker.io/library/ubuntu:15.10
```

上面的命令将拉取 ubuntu 的 15.10 版本的镜像到本地。其中 Digest 可以理解为镜像的散列值，当镜像内部出现改动时，这个散列值将发生改变。

如果使用命令 `docker pull ubuntu` 会怎么样？这会直接拉取最新版本的 ubuntu 镜像，是 `docker pull ubuntu:latest` 的简写。

如果想要知道本地有哪些镜像，可以使用以下命令：

```shell
docker images
```

### 容器

docker 根据指定的镜像可以构建一个容器，容器是独立的，即使多次指定同一个镜像创建容器，那么各个容器之间也还是独立互不干扰的。

例如：

```shell
docker run ubuntu:15.10
```

此时你会发现什么都没发生，不过使用以下命令查看容器状态：

```shell
docker ps --all
```

此时会看到一个 ubuntu 容器处于退出状态，这就是刚才创建的容器。很不幸，这个容器已经关死了，因为没有启动项，也没有把它保持挂起，docker 启动容器后立马就会关闭。

上面的代码将创建一个 ubuntu 的容器，但是仅此而已，容器创建后什么都不会被运行，类似一个空盒子。

所以我们需要让 docker 为此虚拟机分配一个终端给我们，可以在 `run` 后使用 `--tty` 参数让 docker 分配一个虚拟机的终端。命令将变成：

```shell
docker run --tty ubuntu:15.10 # 不可用
```

然后呢，docker 只是分配了一个终端给这个虚拟机并返回给用户？docker 在命令执行结束后并不会关心后续的输入和指令，所以增加还要增加一个 `--interactive` 命令保持标准输入，这样才能使用虚拟机的终端。同时，`--interactive` 也是有另一个功能就是 **保持挂起**，就算不使用 `--tty`，容器也不会立即停止，而是卡着：

```shell
docker run --tty --interactive ubuntu:15.10
```

- `--tty`：分配了一个虚拟机的终端给用户
- `--interactive`：保持 STDIN（标准输入），相当于挂起容器，同时也能输入数据，配合 `--tty` 就可以实现交互。

如果此时执行 `exit`，那么容器就会关闭，我想没人会希望挂起一个终端来开发，所以此时我们需要使用 `--detach` 来把容器放到后台运行，`--detach` 会以分离模式运行 docker 命令。

如果使用 `--detach` 就不需要使用 `--tty` 分配终端了，那么命令可以修改为：

```shell
docker run --interactive --detach ubuntu:15.10
```

`--detach` 还会在分离容器后，返回容器的 ID 值，通过该 ID 值可以对容器进行访问、重启、关闭、删除等操作。

不过一般用户不需要记录此 ID 值，因为可以通过其他命令查看。使用以下命令可以查看当前创建的容器及其状态：

```shell
docker ps --all
```

默认情况下，`docker ps` 不会显示已经关闭的容器，`--all` 参数会显示所有容器，包括已经关闭的。

分离模式下的容器如何访问？

可以使用以下命令来访问一个分离模式下的容器：

```shell
docker exec --tty --interactive 容器ID /bin/bash
```

其中，`/bin/bash` 指定容器的命令，上面的命令访问了指定容器的交互式命令行，并且分配终端保持输入。

容器还有很多命令，比如指定一个容器生成镜像，为容器打标签等等。

### 卷 volume

docker 创建容器没啥问题，然是 docker run 操作，每次都会生成一个新的容器，也就是容器之间的数据是不共享的。

如果大家基于镜像开发，那么就会生成不同的文件，镜像并没有合并操作，不同的数据只能选择其中一份。所以我们必须把生产的数据提升到本地真实的目录中。这个时候卷 volume 就出来了。

volume 可以把本地环境中真实的文件挂载到容器实例中，就类似 linux 的硬盘挂载一样。

比较直接的例子：

- _把数据库的数据文件挂载到本地_

  这样不论我们怎么修改容器，数据首先是安全的，不会因为容器的变更，导致新容器的数据为空或者为过时数据。

- _把应用程序挂在到本地_

  这样只要环境不变，我们每次更新完代码，例如 python、nodejs、rust、php 等，我们只需要把本地代码更新，重新部署容器即可。

卷的使用也很简单，例如：

```shell
docker run --volume "$(pwd):/app" ...
```

其中 `--volume "$(pwd):/app"` 就是把当前路径挂载到虚拟机中的 `/app` 路径下，假设当前路径就是代码文件，那么我们每次更新完代码，只需要删掉旧容器，启动新容器即可完成项目部署。此时容器本身的环境没有任何变化。

这种方式针对代码更新很方便，用户清楚的知道容器里，`/app` 指向了真是环境的当前文件夹。

有的时候我们并不关注数据的位置，我们只是需要一个存储数据的地方，例如 mysql 的数据文件，都是一堆格式化二进制文件，这些文件只需要找个地方存就可以了。那么就可以使用到 docker 中的卷 volume。

**volume 根据关键字在本地环境中映射一个路径**，创建一个 volume 使用以下命令：

```shell
docker volume create mysql-data
```

此时我们就使用 docker 创建了一个名为 `mysql-data` 的卷，它映射了本地环境中的某个文件夹。需要查看这个卷的详细信息，可以使用：

```shell
docker volume inspect mysql-data
```

上面命令将返回我们这个卷的详细信息，其中就包含了它在本地环境中真实的路径。

> windows 用户的话，会发现其路径还是 linux 的路径，这很正常，因为 windows 中的 docker 本身就是运行在一个虚拟机中，所以路径映射的运行是 docker 服务的虚拟机的路径中。mac os 我没试过。

它的用法和前面直接映射本地路径是一样的，例如：

```shell
docker run --volume mysql-data:/home/data/mysql ...
```

`--volume mysql-data:/home/data/mysql` 会把卷 `mysql-data` 映射到容器的 `/home/data/mysql` 路径中，假设你的 mysql 配置此文件夹为数据存放路径，那么数据就会根据映射，存放到卷 `mysql-data` 中，你可以在本机找到对应的数据文件。当下次容器更新时，数据会得到重复使用，而不是创建新的，或者使用容器本身的。

### 网络

docker 创建的容器是互不干扰的，默认情况下，他们不在同一网络中，所以无法进行互相访问，例如算法提供的接口，后端无法访问，前端的 ssr 也不能从后端拿到数据。

docker 为此提供了网络模块，用户可以使用 docker 创建可供容器共享的网络，把多个容器圈到同一个内网当中，此时它们就能实现通信。

写到这里
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111111111111111111111111

## 常用核心命令

**docker 所有命令都可以使用 `--help` 来查看命令含义。** 例如：

```shell
docker --help
docker run --help
docker ps --help
```

类似于 Git 一样，命令那么多，其实常用的来回也就是 `commit`、`add .`、`push`、`pull`、`branch -d`、`checkout -b`、`merge` 那么几个，所以下面也只概述几个常用命令作为参考，并且仅概述功能不说明使用，具体完整的命令参考 [官网 Reference][6]。

### run

**[docker run](https://docs.docker.com/engine/reference/commandline/run/) 命令指定一个镜像创建新容器并执行命令。**，注意是 **新容器**，多次指定同一个镜像创建的容器互不干扰。

例如根据 ubuntu 镜像创建一个新容器，然后在里面启动一个 python 服务器。

参考这里：[Docker run reference](https://docs.docker.com/engine/reference/run/)

### build

**[docker build](https://docs.docker.com/engine/reference/commandline/build/) 命令指定一个 [Dockfile](https://docs.docker.com/engine/reference/builder/) 文件构建镜像**。在 Dockerfile 文件中，可以为构建镜像做很多准备工作。

docker 生成镜像的方式有很多，最直观的就是自己拉取一个镜像生成容器，然后进行相关的环境搭建后，把更新后容器导出为镜像，或者根据修改创建新的镜像。但是这种方式并不能对多端代码进行整合，各段代码都不是那么独立。这种方式适用于对外提供镜像服务，而非业务逻辑代码的分离。

相反 Dockerfile 仅仅是一个小文件，相比镜像的大小，它完全可以放到代码中进行整合。比如隔离端与端之间的运行环境，前端后端算法都可以在自己的代码中嵌入 Dockerfile 文件，每个端根据 Dockerfile 生成相应的容器，被隔离在各自配置的熟悉的环境中互不干扰且能保持通信。

## 零碎的

### 导入导出镜像

windows：

```shell
#To export:
docker container export <container_id> -o <image_name>.tar
#To import
docker image import <image_name>.tar <custom_image_name>
```

linux/mac 可以使用 `>` 代替 `-o`，这源于 windows 的 bug，参见 [issuse 600][2] 和 [stackoverflow][3]：

```bash
#To export:
docker container export <container_id> > <image_name>.tar
#To import
docker image import <image_name>.tar <custom_image_name>
```

加载和保存镜像：

## bugs

- executor failed running [/bin/sh -c something]: exit code: 139

  这个 bug 是我在 windows 上出现的，docker 安装的时候需要安装 wsl 支持虚拟机服务，但是 wsl 对于一些老的系统构建会出现问题。在我使用命令 `docker build -t runoob/centos:6.7 .` 构建 centos:6.7 版本的时候，出现这个 bug 反馈。

  解决：

  [参考链接][b1]，这个问题在多个 Github 上出现过，真的坑。

需要创建 `%userprofile%\.wslconfig` 文件并写入以下代码后 **重启 wsl 服务**：

```
[wsl2]
kernelCommandLine = vsyscall=emulate
```

**一定要记住需要重启 wsl，我是直接重启电脑。**

用处是什么我也不知道，`%userprofile%` 就是用户目录，一般在 `C:\Users\<username>`，视当前用户名查看。

## 引用

- [镜像源][1]
- [docker 中文网教程][4]
- [docker | 菜鸟教程][5]

- [bug: Docker fails to build image with exit code 139.( docker build 的时候，使用的系统过老，导致和 wsl 不兼容)][b1]

[1]: https://www.runoob.com/docker/docker-mirror-acceleration.html
[2]: https://github.com/docker/for-win/issues/660
[3]: https://stackoverflow.com/questions/40622162/docker-load-and-save-archive-tar-invalid-tar-header
[4]: https://docs.docker.com/get-started/overview/
[5]: https://www.runoob.com/docker/docker-tutorial.html
[6]: https://docs.docker.com/engine/reference/run/
[7]: https://hub.docker.com/
[b1]: https://stackoverflow.com/questions/65429435/docker-fails-to-build-image-with-exit-code-139
